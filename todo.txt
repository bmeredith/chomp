Feature thinking:

- make/take model for starting matches (e.g. p1 starts a challenge, p2 can accept)
    - let users specify if they want to be filled against anyone or a specific person

- add held items to monData
    - static and triggered

- add abilities to monData
    - static and triggered

- to think about move implementations:
    - tricky moves to use as examples for edge cases:
        - parting shot
        - destiny bond
        - substitute
        - volt switch
        - barrier/frost veil

    - categorizing move types
        - normal damaging moves (trade-off between accuracy and damage)
        - normal damaging move + % to inflict additional effect (status, stat boost, stamina, etc.)
        - stat boost (2 stages to any one stat) / (1 stage to two stats)
        - healing (reduced healing over time)
        - environmental (hazards/weather/etc.)

dev TODO:
- change up move interface to not return modified state
    - instead, use permissioned system to let the engine give external callers an ability to modify state during the callstack
    - moves instead only return whether or not to force a switch, and then are expected to call the engine to mutate state
    - saves on gas, and should make it clearer when state mutations happen, and which ones they are (more surgical)
    - compared to returning the entire state

- the switch return (each move can at most switch one mon, either the opponent's mon, or the user's mon) will be handled by the engine
- add a new on-switch-in hook to handle both the ability, as well as global effects which run on switch in (specific mon effects can or cannot run on switch in? i guess can have both, no real difference)

- add ability interface (adds on switch in handler--should this just be the case for all events?)
- add way to handle disable as a general privileged status condition