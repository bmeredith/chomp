TODO

1) finish implementing all of the effects
2) write tests for the effects
3) deploy the engine/registry
    - create factory for custom attack
    - create factory for custom effect attack
4) Add events to the engine
5) that's enough for now, start working on the client

> write tests for all of these status effects

(Auto cure)
- Sleep, cannot take action, 33% chance of cure every turn, max 3 turns [x]
- Fright, takes 1 stamina damage every turn, 33% chance of cure every turn, max 3 turns [x]

(No cure)
- Frostbite, takes 1/16 damage every turn, reduces special attack by 50% [x]
- Burn, takes 1/16 damage every turn, reduces attack by 50% []
- Poison, takes 1/8 damage every turn []
- Shock, reduces speed by 50%, 25% chance cannot move []

---------------------------------------------------------------------------------------------

- to think about move implementations:
    - tricky moves to use as examples for edge cases:
        - parting shot
        - destiny bond
        - substitute
        - volt switch
        - barrier/frost veil

    - categorizing move types
        - normal damaging moves (trade-off between accuracy and damage)
        - normal damaging move + % to inflict additional effect (status, stat boost, stamina, etc.)
        - stat boost (2 stages to any one stat) / (1 stage to two stats)
        - healing (reduced healing over time)
        - environmental (hazards/weather/etc.)

To implement: 

---------------------------------------------------------------------------------------------

KNOWN BUGGY INTERACTIONS

1) If a move forces a switch and triggers before the other player can make its move
- The Engine handles the case where the stamina is insufficient (it just skips the move)

Ways to mitigate:
- avoid forcing opponent swap outs unless

2) If an effect calls dealDamage() and triggers AfterDamage, it can potentially cause an infinite loop!
(either if it calls dealDamage() on the opposing mon who also has a damaging attack with an AfterDamage trigger)

Ways to mitigate:
- deal damage directly (but skip calling dealDamage) on the Engine
- avoid dealing damage in the afterDamage hook itself, or in ways that are long-lasting

---------------------------------------------------------------------------------------------

Later features:
- name() for mons (use the mon registry)
- store mon registry / index (need to get from team registry)
- team registry should actually just index into the mon registry vs copying the entire struct over
- default validator still needs to check team eligibility in case e.g. move eligibility has changed
    - add validateTeam() helper?
- disabled / anti switch status effect

---------------------------------------------------------------------------------------------